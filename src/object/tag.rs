use std::{
    path::PathBuf,
};

use ordered_multimap::ListOrderedMultimap;

use crate::{
    error::Error,
    repo::GitRepository, refs::ref_create
};

use super::{ObjectHash, object_write, GitObject};

pub struct Tag {
    pub map: ListOrderedMultimap<String, String>,
}

impl Tag {
    pub fn deserialize(data: Vec<u8>) -> Result<Tag, Error> {
        let data = match String::from_utf8(data) {
            Ok(data) => data,
            Err(_) => return Err(Error::BadKVLMFormat),
        };
        let map = crate::kvlm::kvlm_parse(&data)?;

        Ok(Tag {
            map,
        })
    }

    pub fn serialize(&self) -> Vec<u8> {
        crate::kvlm::kvlm_serialize(&self.map).into_bytes()
    }

    pub fn serialize_into(self) -> Vec<u8> {
        self.serialize()
    }
}

pub fn tag_create(repo: &GitRepository, name: &str, hash: &ObjectHash) -> Result<Tag, Error>
{
    let mut map = ListOrderedMultimap::new();

    map.insert("object".to_owned(), hash.to_string());
    map.insert("type".to_owned(), "commit".to_owned());
    map.insert("tag".to_owned(), name.to_owned());
    map.insert("tagger".to_owned(), "wyag <wyag@example.com>".to_owned());
    map.insert("".to_owned(), "A tag generated by wyag, which won't let you customize your message.".to_owned());

    let tag_object = GitObject::Tag(Tag {
        map
    });
    let tag_hash = object_write(&repo, &tag_object)?;

    tag_create_lightweight(&repo, name, &tag_hash)?;

    match tag_object {
        GitObject::Tag(tag) => Ok(tag),
        _ => panic!("tag_object should be GitObject::Tag"),
    }
}

pub fn tag_create_lightweight(repo: &GitRepository, name: &str, hash: &ObjectHash) -> Result<(), Error>
{
    ref_create(repo, PathBuf::from("tags").join(name), hash)?;

    Ok(())
}
